<template>
  <q-card style="min-width: 500px; max-width: 600px">
    <q-card-section class="row items-center">
      <div class="text-h6">
        {{ device ? '–†–µ–¥–∞–∫—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ' : '–î–æ–±–∞–≤—è–Ω–µ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ' }}
      </div>
      <q-space />
      <q-btn icon="close" flat round dense @click="$emit('cancel')" />
    </q-card-section>

    <q-separator />

    <q-card-section class="q-pt-md">
      <q-form @submit="handleSave" class="q-gutter-md">
        <!-- Icon, Device Name and Unit -->
        <div class="row q-gutter-sm">
          <div style="width: 80px;">
            <q-select
              v-model="formData.icon"
              :options="iconOptions"
              label=""
              outlined
              emit-value
              map-options
            >
              <template #option="scope">
                <q-item v-bind="scope.itemProps">
                  <q-item-section avatar>
                    <q-icon :name="scope.opt.value" />
                  </q-item-section>
                  <q-item-section>
                    {{ scope.opt.label }}
                  </q-item-section>
                </q-item>
              </template>
              <template #selected>
                <div class="row items-center justify-center">
                  <q-icon :name="formData.icon || 'device_hub'" size="sm" />
                </div>
              </template>
            </q-select>
          </div>
          <div class="col">
            <q-input
              v-model="formData.name"
              label="–ò–º–µ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ *"
              :rules="[(val) => (val && val.length > 0) || '–ò–º–µ—Ç–æ –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ']"
              outlined
            />
          </div>
          <div style="width: 150px;">
            <q-select
              v-model="formData.unit"
              :options="unitOptionsWithEmpty"
              label="–ú–µ—Ä–Ω–∞ –µ–¥–∏–Ω–∏—Ü–∞ *"
              :rules="[(val) => (val !== null && val !== '' && val !== undefined) || '–ú–µ—Ä–Ω–∞—Ç–∞ –µ–¥–∏–Ω–∏—Ü–∞ –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–∞']"
              outlined
              emit-value
              map-options
            >
              <template #option="scope">
                <q-item v-bind="scope.itemProps">
                  <q-item-section>
                    {{ scope.opt.label }}
                  </q-item-section>
                </q-item>
              </template>
            </q-select>
          </div>
        </div>

        <!-- Physical Type -->
        <q-select
          v-model="formData.physicalType"
          :options="physicalTypeOptions"
          label="–¢–∏–ø *"
          :rules="[(val) => !!val || '–¢–∏–ø—ä—Ç –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω']"
          outlined
          emit-value
          map-options
          @update:model-value="onPhysicalTypeChange"
        />

        <!-- Device Type -->
        <q-select
          v-model="formData.type"
          :options="deviceTypeOptions"
          label="–ú–æ–¥–µ–ª *"
          :rules="[(val) => !!val || '–¢–∏–ø—ä—Ç –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω']"
          :loading="loadingTemplates"
          outlined
          emit-value
          map-options
          @update:model-value="onDeviceTypeChange"
        />

        <!-- Controller -->
        <q-select
          v-model="formData.controllerId"
          :options="controllerOptions"
          label="–°–≤—ä—Ä–∑–∞–Ω –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä *"
          :rules="[(val) => !!val || '–ö–æ–Ω—Ç—Ä–æ–ª–µ—Ä—ä—Ç –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω']"
          outlined
          emit-value
          map-options
          option-disable="disable"
          @update:model-value="onControllerChange"
        >
          <!-- Custom template –∑–∞ –¥–∞ –ø–æ–∫–∞–∂–µ–º tooltip -->
          <template v-slot:option="{ itemProps, opt }">
            <q-item v-bind="itemProps" :disable="opt.disable">
              <q-item-section>
                <q-item-label :class="{ 'disabled-controller': opt.disable }">
                  {{ opt.label }}
                </q-item-label>
              </q-item-section>
              <q-tooltip v-if="opt.disable">
                –¢–æ–∑–∏ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä –Ω—è–º–∞ –ø–æ–¥—Ö–æ–¥—è—â–∞ –∫–æ–º–∞–Ω–¥–∞
              </q-tooltip>
            </q-item>
          </template>
        </q-select>

        <!-- Connection Method -->
        <q-select
          v-model="formData.connectionMethod"
          :options="connectionMethodOptions"
          label="–ú–µ—Ç–æ–¥ –Ω–∞ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ *"
          :rules="[(val) => !!val || '–ú–µ—Ç–æ–¥—ä—Ç –Ω–∞ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω']"
          outlined
          emit-value
          map-options
          @update:model-value="onConnectionMethodChange"
        />

        <!-- Relay Selection (shown when Relay method is selected) -->
        <q-select
          v-if="formData.connectionMethod === 'relay'"
          v-model="formData.relayId"
          :options="relayOptions"
          label="–ò–∑–±–µ—Ä–∏ —Ä–µ–ª–µ *"
          :rules="[(val) => !!val || '–†–µ–ª–µ—Ç–æ –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ']"
          outlined
          emit-value
          map-options
          :loading="loadingRelays"
          @update:model-value="onRelayChange"
        />

        <!-- Relay Port Selection (shown when relay is selected) -->
        <q-select
          v-if="formData.connectionMethod === 'relay' && formData.relayId"
          v-model="formData.relayPort"
          :options="relayPortOptions"
          label="–ò–∑–±–µ—Ä–∏ –ø–æ—Ä—Ç –Ω–∞ —Ä–µ–ª–µ—Ç–æ"
          :rules="[]"
          outlined
          emit-value
          map-options
          option-disable="disable"
        >
          <template v-slot:append v-if="formData.relayPort !== null">
            <q-icon name="clear" @click="clearRelayPort" class="cursor-pointer" />
          </template>
          <!-- Custom option template with chips - same as direct ports -->
          <template v-slot:option="{ itemProps, opt }">
            <q-item v-bind="itemProps" :disable="opt.disable">
              <q-item-section>
                <div class="row items-center q-gutter-xs">
                  <q-chip :color="opt.portType === 'empty' ? 'grey-5' : 'blue-6'" text-color="white" size="sm" dense>
                    {{ opt.portKey }}
                  </q-chip>
                  <q-chip v-if="opt.portType !== 'empty'" color="green-6" text-color="white" size="sm" dense>
                    {{ opt.portType }}
                  </q-chip>
                  <q-chip v-if="opt.currentState" :color="opt.stateColor" text-color="white" size="sm" dense>
                    {{ opt.currentState }}
                  </q-chip>
                  <q-chip v-if="opt.disable" color="grey" text-color="white" size="sm" dense>
                    Occupied
                  </q-chip>
                  <span class="text-caption text-grey-6">{{ opt.description }}</span>
                </div>
              </q-item-section>
            </q-item>
          </template>
          
          <!-- Custom selected value template - same as direct ports -->
          <template v-slot:selected-item="{ opt }">
            <div class="row items-center q-gutter-xs">
              <q-chip :color="opt.portType === 'empty' ? 'grey-5' : 'blue-6'" text-color="white" size="sm" dense>
                {{ opt.portKey }}
              </q-chip>
              <q-chip v-if="opt.portType !== 'empty'" color="green-6" text-color="white" size="sm" dense>
                {{ opt.portType }}
              </q-chip>
              <q-chip v-if="opt.currentState" :color="opt.stateColor" text-color="white" size="sm" dense>
                {{ opt.currentState }}
              </q-chip>
            </div>
          </template>
        </q-select>

        <!-- Template Port Requirements - Hidden when using relay connection -->
        <div v-if="selectedTemplate && formData.connectionMethod === 'direct'" class="q-mt-md">
          <q-separator />
          <div class="text-subtitle2 q-mt-md q-mb-sm">
            –ü–æ—Ä—Ç–æ–≤–µ –∑–∞ {{ selectedTemplate.displayName }}
          </div>
          
          <div v-for="portReq in selectedTemplate.portRequirements" :key="portReq.role" class="q-mb-md">
            <q-select
              v-model="formData.ports[getPortIndex(portReq.role)]"
              :options="getPortOptionsForType(portReq.type)"
              :label="`${portReq.role} –ø–æ—Ä—Ç (${portReq.type}) ${portReq.required ? '*' : ''}`"
              :rules="[]"
              outlined
              emit-value
              map-options
              option-disable="disable"
            >
              <template v-slot:append v-if="formData.ports[getPortIndex(portReq.role)]">
                <q-icon name="clear" @click="clearTemplatePort(portReq.role)" class="cursor-pointer" />
              </template>
              <template v-slot:hint>
                {{ portReq.description }}
              </template>
              
              <!-- Custom option template with chips -->
              <template v-slot:option="{ itemProps, opt }">
                <q-item v-bind="itemProps" :disable="opt.disable">
                  <q-item-section>
                    <div class="row items-center q-gutter-xs">
                      <q-chip :color="opt.portType === 'empty' ? 'grey-5' : 'blue-6'" text-color="white" size="sm" dense>
                        {{ opt.portKey }}
                      </q-chip>
                      <q-chip v-if="opt.portType !== 'empty'" color="green-6" text-color="white" size="sm" dense>
                        {{ opt.portType }}
                      </q-chip>
                      <q-chip v-if="opt.currentState" :color="opt.stateColor" text-color="white" size="sm" dense>
                        {{ opt.currentState }}
                      </q-chip>
                      <span class="text-caption text-grey-6">{{ opt.description }}</span>
                    </div>
                  </q-item-section>
                </q-item>
              </template>
              
              <!-- Custom selected value template -->
              <template v-slot:selected-item="{ opt }">
                <div class="row items-center q-gutter-xs">
                  <q-chip :color="opt.portType === 'empty' ? 'grey-5' : 'blue-6'" text-color="white" size="sm" dense>
                    {{ opt.portKey }}
                  </q-chip>
                  <q-chip v-if="opt.portType !== 'empty'" color="green-6" text-color="white" size="sm" dense>
                    {{ opt.portType }}
                  </q-chip>
                  <q-chip v-if="opt.currentState" :color="opt.stateColor" text-color="white" size="sm" dense>
                    {{ opt.currentState }}
                  </q-chip>
                </div>
              </template>
            </q-select>
          </div>
        </div>

        <!-- Fallback Ports Section - DEPRECATED: Legacy port management, replaced by template-based port requirements -->
        <!-- 
        <DevicePortsTable
          v-if="!selectedTemplate"
          v-model="formData.ports"
          :controller-id="formData.controllerId"
          :controllers="controllers"
          @port-toggle="handlePortToggle"
        />
        -->


        <!-- Info: Device testing is now handled directly in the ports table -->


        <!-- Description -->
        <q-input
          v-model="formData.description"
          label="–û–ø–∏—Å–∞–Ω–∏–µ / –ö–æ–º–µ–Ω—Ç–∞—Ä"
          type="textarea"
          rows="3"
          outlined
        />

        <!-- Sensor Validation Configuration -->
        <div v-if="formData.category === 'sensor'" class="q-mt-md">
          <q-expansion-item
            icon="health_and_safety"
            label="–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ —Å–µ–Ω–∑–æ—Ä–∞"
            :default-opened="formData.healthCheckEnabled"
            header-class="text-h6"
          >
            <div class="q-pa-md bg-grey-1 rounded-borders">
              <div class="column q-gutter-md">
                <!-- Enable Validation -->
                <q-toggle
                  v-model="formData.healthCheckEnabled"
                  label="–í–∫–ª—é—á–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ —Å–µ–Ω–∑–æ—Ä–∞"
                  color="positive"
                />

                <div v-if="formData.healthCheckEnabled" class="column q-gutter-md">
                  <!-- Expected Range -->
                  <div class="text-subtitle2 q-mb-sm">–û—á–∞–∫–≤–∞–Ω –¥–∏–∞–ø–∞–∑–æ–Ω –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏—Ç–µ</div>
                  <div class="row q-gutter-md">
                    <q-input
                      v-model.number="formData.validationConfig.expectedMin"
                      label="–ú–∏–Ω–∏–º—É–º *"
                      type="number"
                      outlined
                      dense
                      style="max-width: 120px"
                      :rules="[(val) => val !== null && val !== undefined || '–ó–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –ø–æ–ª–µ']"
                    />
                    <q-input
                      v-model.number="formData.validationConfig.expectedMax"
                      label="–ú–∞–∫—Å–∏–º—É–º *"
                      type="number"
                      outlined
                      dense
                      style="max-width: 120px"
                      :rules="[(val) => val !== null && val !== undefined || '–ó–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –ø–æ–ª–µ']"
                    />
                  </div>

                  <!-- Physical Range -->
                  <div class="text-subtitle2 q-mb-sm">–§–∏–∑–∏—á–µ—Å–∫–∏ –¥–∏–∞–ø–∞–∑–æ–Ω (—Ö–∞—Ä–¥—É–µ—Ä–Ω–∏ –ª–∏–º–∏—Ç–∏)</div>
                  <div class="row q-gutter-md">
                    <q-input
                      v-model.number="formData.validationConfig.physicalMin"
                      label="–§–∏–∑. –º–∏–Ω–∏–º—É–º *"
                      type="number"
                      outlined
                      dense
                      style="max-width: 120px"
                      :rules="[(val) => val !== null && val !== undefined || '–ó–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –ø–æ–ª–µ']"
                    />
                    <q-input
                      v-model.number="formData.validationConfig.physicalMax"
                      label="–§–∏–∑. –º–∞–∫—Å–∏–º—É–º *"
                      type="number"
                      outlined
                      dense
                      style="max-width: 120px"
                      :rules="[(val) => val !== null && val !== undefined || '–ó–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –ø–æ–ª–µ']"
                    />
                  </div>

                  <!-- Advanced Settings -->
                  <div class="text-subtitle2 q-mb-sm">–î–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</div>
                  <div class="column q-gutter-md">
                    <q-input
                      v-model.number="formData.validationConfig.maxChangeRate"
                      label="–ú–∞–∫—Å. –ø—Ä–æ–º—è–Ω–∞ –≤ –º–∏–Ω—É—Ç–∞"
                      type="number"
                      outlined
                      dense
                      style="max-width: 180px"
                      hint="–ú–∞–∫—Å–∏–º–∞–ª–Ω–∞ –¥–æ–ø—É—Å—Ç–∏–º–∞ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –∑–∞ –º–∏–Ω—É—Ç–∞"
                    />
                    <q-input
                      v-model.number="formData.validationConfig.historyWindow"
                      label="–ß–∞—Å–æ–≤–µ –∑–∞ –∞–Ω–∞–ª–∏–∑"
                      type="number"
                      outlined
                      dense
                      style="max-width: 180px"
                      hint="–ö–æ–ª–∫–æ —á–∞—Å–∞ –Ω–∞–∑–∞–¥ –¥–∞ –∞–Ω–∞–ª–∏–∑–∏—Ä–∞ –¥–∞–Ω–Ω–∏—Ç–µ"
                    />
                    <q-input
                      v-model.number="formData.validationConfig.stuckValueThreshold"
                      label="–õ–∏–º–∏—Ç –∑–∞ –±–ª–æ–∫–∏—Ä–∞–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç (–º–∏–Ω)"
                      type="number"
                      outlined
                      dense
                      style="max-width: 180px"
                      hint="–°–ª–µ–¥ –∫–æ–ª–∫–æ –º–∏–Ω—É—Ç–∏ –¥–∞ —Å–µ —Å—á–∏—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –∑–∞ –±–ª–æ–∫–∏—Ä–∞–Ω–∞"
                    />
                  </div>
                </div>
              </div>
            </div>
          </q-expansion-item>
        </div>

        <!-- Status and Priority -->
        <div class="column q-gutter-sm">
          <div class="row items-center q-gutter-md">
            <q-toggle
              v-model="formData.isActive"
              label="–ê–∫—Ç–∏–≤–Ω–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"
              color="positive"
              :disable="!hasConfiguredPorts"
            />
            <q-select
              v-model="formData.priority"
              :options="priorityOptions"
              label="–ù–∏–≤–æ –Ω–∞ –≤–∞–∂–Ω–æ—Å—Ç"
              style="min-width: 180px"
              outlined
              dense
              emit-value
              map-options
            />
          </div>
          <div v-if="!hasConfiguredPorts" class="text-caption text-orange q-ml-md">
            <q-icon name="warning" class="q-mr-xs" />
            –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ –Ω—è–º–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω–∏ –ø–æ—Ä—Ç–æ–≤–µ –∏ —â–µ –±—ä–¥–µ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–∞–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
          </div>
        </div>
      </q-form>
    </q-card-section>

    <q-separator />

    <q-card-actions align="right" class="q-pa-md">
      <q-btn
        flat
        label="–û—Ç–∫–∞–∑"
        color="grey"
        @click="$emit('cancel')"
      />
      <q-btn
        label="üíæ –ó–∞–ø–∞–∑–∏"
        color="primary"
        @click="handleSave"
        :loading="saving"
      />
    </q-card-actions>
  </q-card>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted } from 'vue'
import { useQuasar } from 'quasar'
import { controllerApi, api } from '../services/api'
import deviceTemplateApi from '../services/device-template-api'
import controllerTemplates from '../pages/assets/data/controller-templates.json'
// import DevicePortsTable from './DevicePortsTable.vue' // DEPRECATED: Legacy port management component

// Type definitions for better TypeScript support
interface RelayPort {
  portNumber: number
  controlPin: string
  isOccupied: boolean
  [key: string]: any
}

interface PortRequirement {
  name: string
  type: string
  required: boolean
  [key: string]: any
}

// Props
interface Props {
  device?: any
  controllers: any[]
  deviceTypes: any[]
}

const props = withDefaults(defineProps<Props>(), {
  device: null,
  controllers: () => [],
  deviceTypes: () => []
})

// Emits
const emit = defineEmits(['save', 'cancel'])

const $q = useQuasar()

// Data
const saving = ref(false)
const loadingTemplates = ref(false)
const loadingRelays = ref(false)
const deviceTemplates = ref<any[]>([])
const selectedTemplate = ref<any>(null)
const relays = ref<any[]>([])
const selectedRelay = ref<any>(null)

const formData = ref({
  name: '',
  type: '',
  physicalType: '',
  category: '',
  controllerId: '',
  connectionMethod: 'direct',
  relayId: '',
  relayPort: null,
  ports: [] as string[],
  description: '',
  isActive: true,
  priority: 'normal',
  healthCheckEnabled: false,
  icon: 'device_hub',
  unit: null,
  validationConfig: {
    enabled: false,
    expectedMin: 0,
    expectedMax: 100,
    physicalMin: 0,
    physicalMax: 1023,
    maxChangeRate: 10,
    historyWindow: 24,
    stuckValueThreshold: 30
  }
})

// Test functionality moved to DevicePortsTable

// Computed
const physicalTypeOptions = computed(() => {
  // Get unique physicalType values from deviceTemplates
  const uniquePhysicalTypes = [...new Set(deviceTemplates.value.map(template => template.physicalType))]
  
  // Add "–í—Å–∏—á–∫–∏" option at the beginning
  const options = [{
    label: '–í—Å–∏—á–∫–∏ —Ç–∏–ø–æ–≤–µ',
    value: 'all'
  }]
  
  // Add actual physical types
  options.push(...uniquePhysicalTypes.map(physicalType => ({
    label: getPhysicalTypeDisplayName(physicalType),
    value: physicalType
  })))
  
  return options
})

const deviceTypeOptions = computed(() => {
  // If no physicalType selected or "all" selected, show all templates
  if (!formData.value.physicalType || formData.value.physicalType === 'all') {
    return deviceTemplates.value.map(template => ({
      label: template.displayName,
      value: template.type,
      template: template
    }))
  }
  
  // Filter templates by selected physicalType
  return deviceTemplates.value
    .filter(template => template.physicalType === formData.value.physicalType)
    .map(template => ({
      label: template.displayName,
      value: template.type,
      template: template
    }))
})

const controllerOptions = computed(() =>
  props.controllers.map(controller => ({
    label: controller.name,
    value: controller._id,
    controller: controller
  }))
)

const priorityOptions = computed(() => [
  { label: '–ö—Ä–∏—Ç–∏—á–Ω–æ', value: 'critical', color: 'red' },
  { label: '–í–∏—Å–æ–∫–æ', value: 'high', color: 'orange' },
  { label: '–ù–æ—Ä–º–∞–ª–Ω–æ', value: 'normal', color: 'blue' },
  { label: '–°–ª–∞–±–æ', value: 'low', color: 'grey' }
])

const connectionMethodOptions = computed(() => [
  { label: '–î–∏—Ä–µ–∫—Ç–Ω–æ –∫—ä–º –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä', value: 'direct' },
  { label: '–ß—Ä–µ–∑ —Ä–µ–ª–µ', value: 'relay' }
])

const iconOptions = computed(() => [
  { label: '–¢–µ—Ä–º–æ–º–µ—Ç—ä—Ä', value: 'thermostat' },
  { label: '–ù–∞—É–∫–∞', value: 'science' },
  { label: '–ï–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ', value: 'electrical_services' },
  { label: '–ö–∞–ø–∫–∞ –≤–æ–¥–∞', value: 'water_drop' },
  { label: '–†–∞–∑—Å—Ç–æ—è–Ω–∏–µ', value: 'straighten' },
  { label: '–ï–Ω–µ—Ä–≥–∏—è', value: 'power' },
  { label: '–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ', value: 'device_hub' },
  { label: '–î–∞—Ç—á–∏–∫', value: 'sensors' },
  { label: '–í–∫–ª—é—á–µ–Ω', value: 'power_on' },
  { label: '–ò–∑–∫–ª—é—á–µ–Ω', value: 'power_off' },
  { label: '–ë–∞—Ç–µ—Ä–∏—è', value: 'battery_full' },
  { label: 'WiFi', value: 'wifi' },
  { label: 'Bluetooth', value: 'bluetooth' },
  { label: 'USB', value: 'usb' },
  { label: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏', value: 'settings' },
  { label: '–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏', value: 'build' },
  { label: '–ö–æ–Ω—Ç—Ä–æ–ª', value: 'tune' },
  { label: '–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥', value: 'monitor' },
  { label: '–¶–∏—Ñ—Ä–æ–≤–æ', value: 'memory' },
  { label: '–ê–Ω–∞–ª–æ–≥–æ–≤–æ', value: 'show_chart' },
  { label: '–ê–≥—Ä–æ–Ω–æ–º', value: 'agriculture' },
  { label: '–†–∞—Å—Ç–µ–Ω–∏–µ', value: 'local_florist' },
  { label: '–°–ª—ä–Ω—Ü–µ', value: 'wb_sunny' },
  { label: '–°–≤–µ—Ç–ª–∏–Ω–∞', value: 'lightbulb' },
  { label: '–í–µ–Ω—Ç–∏–ª–∞—Ç–æ—Ä', value: 'air' },
  { label: '–ü–æ–º–ø–∞', value: 'water_pump' },
  { label: '–§–∏–ª—Ç—ä—Ä', value: 'filter_alt' },
  { label: '–ö–ª–∞–ø–∞–Ω', value: 'valve' },
  { label: '–•—Ä–∞–Ω–µ–Ω–µ', value: 'restaurant' },
  { label: '–†–µ–∑–µ—Ä–≤–æ–∞—Ä', value: 'propane_tank' }
])

const baseUnitOptions = [
  { label: '%', value: '%' },
  { label: 'pH', value: 'pH' },
  { label: 'mS/cm', value: 'mS' },
  { label: '¬µS/cm', value: '¬µS' },
  { label: '¬∞C', value: '¬∞C' },
  { label: '—Å–µ–∫', value: '—Å–µ–∫' },
  { label: '–º–∏–Ω', value: '–º–∏–Ω' },
  { label: '—á', value: '—á' },
  { label: '–ª', value: '–ª' },
  { label: '–º–ª', value: '–º–ª' },
  { label: '—Å–º', value: '—Å–º' },
  { label: '–º', value: '–º' }
]

const unitOptionsWithEmpty = computed(() => [
  { label: '', value: '' },
  ...baseUnitOptions
])

const relayOptions = computed(() =>
  relays.value
    .filter(relay => relay.controllerId === formData.value.controllerId && relay.isActive)
    .map(relay => ({
      label: `${relay.name} (${relay.relayType})`,
      value: relay._id,
      relay: relay
    }))
)

const relayPortOptions = computed(() => {
  if (!selectedRelay.value || !selectedRelay.value.ports) return []
  
  // Start with "–ü—Ä–∞–∑–µ–Ω" option
  const options = [{
    label: '–ü—Ä–∞–∑–µ–Ω',
    value: null,
    portKey: '–ü—Ä–∞–∑–µ–Ω',
    portType: 'empty',
    currentState: '',
    stateColor: 'grey-5',
    description: '–ù–µ–∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω –ø–æ—Ä—Ç',
    disable: false
  }]
  
  // Add relay ports
  const relayPorts = selectedRelay.value.ports
    .map((port: RelayPort) => {
      // Port is disabled if occupied OR has no controlPin (not configured)
      const hasControlPin = port.controlPin && port.controlPin.trim() !== ''
      const isDisabled = port.isOccupied || !hasControlPin
      
      // Determine state color based on HIGH/LOW - same logic as direct ports
      let stateColor = 'orange-6'
      if (!hasControlPin) {
        stateColor = 'grey-5' // Grey for ports without controlPin
      } else if (port.currentState === 'HIGH') {
        stateColor = 'red-6'
      } else if (port.currentState === 'LOW') {
        stateColor = 'grey-7'
      }
      
      return {
        label: `–ü–æ—Ä—Ç ${port.portNumber} (${port.controlPin || '–ù—è–º–∞ –ø–∏–Ω'})`,
        value: port.portNumber,
        portKey: `–ü–æ—Ä—Ç ${port.portNumber}`,
        portType: 'digital',
        currentState: hasControlPin ? port.currentState : 'N/A',
        stateColor: stateColor,
        description: port.controlPin || '–ù—è–º–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω –ø–∏–Ω',
        disable: isDisabled,
        port: port
      }
    })
    
  return [...options, ...relayPorts]
})

// Check if this is a new device (no device prop or no _id)
const isNewDevice = computed(() => {
  return !props.device || !props.device._id
})

// Check if this is a relay device (relay, pumps, solenoid_valve)
const isRelayDevice = computed(() => {
  const deviceType = formData.value.type
  return deviceType === 'relay' || deviceType === 'pumps' ||deviceType === 'solenoid_valve'
})

// Check if device has configured ports
const hasConfiguredPorts = computed(() => {
  if (formData.value.connectionMethod === 'relay') {
    return formData.value.relayPort !== null
  } else {
    const cleanedPorts = formData.value.ports.filter(port => port && port.trim() !== '')
    return cleanedPorts.length > 0
  }
})



// Test functionality moved to DevicePortsTable component

// Removed old port management functions - handled by DevicePortsTable now

async function handleSave() {
  saving.value = true
  const wasNewDevice = isNewDevice.value
  
  try {
    // Validate required fields
    if (!formData.value.name || !formData.value.type || !formData.value.physicalType || !formData.value.controllerId || !formData.value.connectionMethod) {
      $q.notify({
        type: 'negative',
        message: '–ú–æ–ª—è –ø–æ–ø—ä–ª–Ω–µ—Ç–µ –≤—Å–∏—á–∫–∏ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–∏ –ø–æ–ª–µ—Ç–∞'
      })
      saving.value = false
      return
    }

    // Validate unit is selected
    if (!formData.value.unit || formData.value.unit === '') {
      $q.notify({
        type: 'negative',
        message: '–ú–æ–ª—è –∏–∑–±–µ—Ä–µ—Ç–µ –º–µ—Ä–Ω–∞ –µ–¥–∏–Ω–∏—Ü–∞'
      })
      saving.value = false
      return
    }

    // Validate controller has required command
    if (selectedTemplate.value?.executionConfig?.commandType) {
      const requiredCommand = selectedTemplate.value.executionConfig.commandType
      const selectedController = props.controllers.find(c => c._id === formData.value.controllerId)

      if (selectedController && !selectedController.capabilities?.includes(requiredCommand)) {
        $q.notify({
          type: 'negative',
          message: `–ò–∑–±—Ä–∞–Ω–∏—è—Ç –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä "${selectedController.name}" –Ω—è–º–∞ –Ω—É–∂–Ω–∞—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ "${requiredCommand}" –∑–∞ —Ç–æ–∑–∏ —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ. –ú–æ–ª—è –∏–∑–±–µ—Ä–µ—Ç–µ –¥—Ä—É–≥ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä.`
        })
        saving.value = false
        return
      }
    }

    // Validate physicalType is not "all"
    if (formData.value.physicalType === 'all') {
      $q.notify({
        type: 'negative',
        message: '–ú–æ–ª—è –∏–∑–±–µ—Ä–µ—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω —Ñ–∏–∑–∏—á–µ—Å–∫–∏ —Ç–∏–ø, –∞ –Ω–µ "–í—Å–∏—á–∫–∏ —Ç–∏–ø–æ–≤–µ"'
      })
      return
    }

    // Validate relay connection fields
    if (formData.value.connectionMethod === 'relay') {
      if (!formData.value.relayId) {
        $q.notify({
          type: 'negative',
          message: '–ú–æ–ª—è –∏–∑–±–µ—Ä–µ—Ç–µ —Ä–µ–ª–µ –∑–∞ —Ä–µ–ª–µ–π–Ω–æ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ'
        })
        return
      }
      
      if (formData.value.relayPort === null) {
        // Show confirmation dialog for relay devices without port
        const confirmed = await new Promise((resolve) => {
          $q.dialog({
            title: '–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ',
            message: '–ù–µ –µ –∏–∑–±—Ä–∞–Ω –ø–æ—Ä—Ç –Ω–∞ —Ä–µ–ª–µ—Ç–æ. –ò—Å–∫–∞—Ç–µ –ª–∏ –¥–∞ –ø—Ä–æ–¥—ä–ª–∂–∏—Ç–µ?',
            cancel: true,
            persistent: true
          }).onOk(() => resolve(true))
           .onCancel(() => resolve(false))
        })
        
        if (!confirmed) {
          return // User canceled, stay in edit mode
        }
      }
    }

    // Port validation - different logic for relay vs direct connection
    if (formData.value.connectionMethod === 'relay') {
      // For relay connection, use relay port as device port
      if (formData.value.relayPort !== null && selectedRelay.value) {
        const relayPort = selectedRelay.value?.ports.find((p: RelayPort) => p.portNumber === formData.value.relayPort)
        if (relayPort) {
          formData.value.ports = [relayPort.controlPin]
        }
      }
    } else {
      // Template-based port validation for direct connection with confirmation
      if (selectedTemplate.value) {
        const requiredPorts = selectedTemplate.value.portRequirements.filter((req: any) => req.required)
        const missingPorts = requiredPorts.filter((req: any) => {
          const index = getPortIndex(req.role)
          return !formData.value.ports[index] || formData.value.ports[index]?.trim() === ''
        })
        
        if (missingPorts.length > 0) {
          // Show confirmation dialog for missing required ports
          const portsList = missingPorts.map((p: any) => p.role).join(', ')
          const confirmed = await new Promise((resolve) => {
            $q.dialog({
              title: '–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ',
              message: `–ù–µ —Å–∞ –∏–∑–±—Ä–∞–Ω–∏ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–∏ –ø–æ—Ä—Ç–æ–≤–µ: ${portsList}. –ò—Å–∫–∞—Ç–µ –ª–∏ –¥–∞ –ø—Ä–æ–¥—ä–ª–∂–∏—Ç–µ?`,
              cancel: true,
              persistent: true
            }).onOk(() => resolve(true))
             .onCancel(() => resolve(false))
          })
          
          if (!confirmed) {
            return // User canceled, stay in edit mode
          }
        }
      }
    }

    // Final port validation - allow empty ports after confirmation dialogs
    const cleanedPorts = formData.value.ports.filter(port => port && port.trim() !== '')
    
    // Note: Empty ports are now allowed after confirmation dialogs above

    const deviceData = {
      ...formData.value,
      ports: cleanedPorts
    }

    // Debug: Log the data being sent
    console.log('[DeviceForm] Saving device data:', JSON.stringify(deviceData, null, 2))

    emit('save', deviceData)
  } catch (error) {
    console.error('[DeviceForm] Error in handleSave:', error)
    $q.notify({
      type: 'negative',
      message: '–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞–ø–∞–∑–≤–∞–Ω–µ'
    })
  } finally {
    saving.value = false
  }
}

// Load device templates on mount
async function loadDeviceTemplates() {
  loadingTemplates.value = true
  try {
    deviceTemplates.value = await deviceTemplateApi.getAll()
  } catch (error) {
    console.error('[DeviceForm] Error loading device templates:', error)
    $q.notify({
      type: 'negative',
      message: '–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ç–∏–ø–æ–≤–µ—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞'
    })
  } finally {
    loadingTemplates.value = false
  }
}

// Load relays for a specific controller
async function loadRelaysForController(controllerId: string) {
  if (!controllerId) return
  
  loadingRelays.value = true
  try {
    const response = await api.getClient().get(`/relays?controllerId=${controllerId}&isActive=true`)
    relays.value = response.data.data || []
    console.log(`[DeviceForm] Loaded ${relays.value.length} relays for controller ${controllerId}`)
  } catch (error) {
    console.error('[DeviceForm] Error loading relays:', error)
    $q.notify({
      type: 'negative',
      message: '–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ä–µ–ª–µ—Ç–∞—Ç–∞'
    })
  } finally {
    loadingRelays.value = false
  }
}

// Handle physical type change
function onPhysicalTypeChange(newPhysicalType: string) {
  console.log(`[DeviceForm] Physical type changed to: ${newPhysicalType}`)
  
  // Reset device type when physical type changes
  formData.value.type = ''
  selectedTemplate.value = null
  formData.value.ports = []
}

// Handle device type change
function onDeviceTypeChange(newType: string) {
  const template = deviceTemplates.value.find(t => t.type === newType)
  selectedTemplate.value = template
  
  // Auto-set physicalType if "–í—Å–∏—á–∫–∏" is selected and model is chosen
  if (formData.value.physicalType === 'all' && template) {
    console.log(`[DeviceForm] Auto-setting physicalType to: ${template.physicalType}`)
    formData.value.physicalType = template.physicalType
  }
  
  // Auto-set category based on device type
  if (template) {
    // Determine category based on device type
    const relayTypes = ['relay', 'pumps', 'solenoid_valve']
    formData.value.category = relayTypes.includes(template.type) ? 'actuator' : 'sensor'
    console.log(`[DeviceForm] Auto-setting category to: ${formData.value.category}`)
  }
  
  // Reset ports when changing device type
  if (template) {
    formData.value.ports = new Array(template.portRequirements.length).fill('')
  } else {
    formData.value.ports = []
  }
}

// Handle controller change
function onControllerChange(controllerId: string) {
  // Reset relay-related fields when controller changes
  formData.value.relayId = ''
  formData.value.relayPort = null
  selectedRelay.value = null
  
  // Load relays for the new controller
  if (controllerId) {
    loadRelaysForController(controllerId)
  }
}

// Clear port methods
function clearRelayPort() {
  // When relay port is cleared, switch to direct connection and clear relay data
  formData.value.relayPort = null
  formData.value.connectionMethod = 'direct'
  formData.value.relayId = ''
  selectedRelay.value = null
  console.log('[DeviceForm] Relay port cleared - switched to direct connection')
}

function clearTemplatePort(role: string) {
  const index = getPortIndex(role)
  formData.value.ports[index] = ''
}

// Handle connection method change
function onConnectionMethodChange(method: string) {
  if (method === 'direct') {
    // Reset relay fields when switching to direct connection
    formData.value.relayId = ''
    formData.value.relayPort = null
    selectedRelay.value = null
  }
}

// Handle relay change
function onRelayChange(relayId: string) {
  const relay = relays.value.find(r => r._id === relayId)
  selectedRelay.value = relay
  formData.value.relayPort = null // Reset port selection
}

// Get display name for physical type
function getPhysicalTypeDisplayName(physicalType: string): string {
  const displayNames: Record<string, string> = {
    'ph': 'pH –°–µ–Ω–∑–æ—Ä–∏',
    'ec': 'EC –°–µ–Ω–∑–æ—Ä–∏',
    'moisture': '–í–ª–∞–∂–Ω–æ—Å—Ç–Ω–∏ –°–µ–Ω–∑–æ—Ä–∏',
    'ultrasonic': '–£–ª—Ç—Ä–∞–∑–≤—É–∫–æ–≤–∏ –°–µ–Ω–∑–æ—Ä–∏',
    'relay': '–†–µ–ª–µ—Ç–∞ / –ü–æ–º–ø–∏ / –ö–ª–∞–ø–∞–Ω–∏',
    'temperature': '–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–Ω–∏ –°–µ–Ω–∑–æ—Ä–∏',
    'temperature_humidity': '–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ + –í–ª–∞–∂–Ω–æ—Å—Ç',
    'flow': '–î–µ–±–∏—Ç–æ–º–µ—Ä–∏',
    'level': '–°–µ–Ω–∑–æ—Ä–∏ –∑–∞ –ù–∏–≤–æ',
    'light': '–°–≤–µ—Ç–ª–∏–Ω–Ω–∏ –°–µ–Ω–∑–æ—Ä–∏'
  }
  return displayNames[physicalType] || physicalType.toUpperCase()
}

// Get icon label by value
function getIconLabel(iconValue: string): string {
  if (!iconValue) return '–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ'
  const option = iconOptions.value.find(opt => opt.value === iconValue)
  return option ? option.label : iconValue
}

// Create custom unit value (max 4 characters)
function createUnitValue(val: string, done: (item?: any, mode?: string) => void) {
  const trimmedVal = val.trim()
  if (trimmedVal.length > 0 && trimmedVal.length <= 4) {
    done({ label: trimmedVal, value: trimmedVal }, 'add-unique')
  }
}

// Get port index by role
function getPortIndex(role: string): number {
  if (!selectedTemplate.value) return 0
  return selectedTemplate.value.portRequirements.findIndex((req: any) => req.role === role)
}

// Get port options with separate chips for key, type, and state
function getPortOptionsForType(portType: string) {
  const selectedController = props.controllers.find(c => c._id === formData.value.controllerId)
  if (!selectedController) return []
  
  // Debug: log what we're working with
  console.log(`[DeviceForm] Looking for portType: ${portType}`)
  console.log('[DeviceForm] Available ports:', selectedController.availablePorts)
  
  // Start with "–ü—Ä–∞–∑–µ–Ω" option
  const options = [{
    label: '–ü—Ä–∞–∑–µ–Ω',
    value: '',
    portKey: '–ü—Ä–∞–∑–µ–Ω',
    portType: 'empty',
    currentState: '',
    stateColor: 'grey-5',
    description: '–ù–µ–∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω –ø–æ—Ä—Ç',
    disable: false
  }]
  
  // Add controller ports
  const controllerPorts = selectedController.availablePorts
    .filter((port: any) => port.type === portType)
    .map((port: any) => {
      const isDisabled = !port.isActive || port.isOccupied
      
      // Determine state color based on HIGH/LOW
      let stateColor = 'orange-6'
      if (port.currentState === 'HIGH') {
        stateColor = 'red-6'
      } else if (port.currentState === 'LOW') {
        stateColor = 'grey-7'
      }
      
      return {
        label: port.key,
        value: port.key,
        portKey: port.key,
        portType: port.type,
        currentState: port.currentState,
        stateColor: stateColor,
        description: port.label || port.description || '',
        disable: isDisabled
      }
    })
    
  return [...options, ...controllerPorts]
}

/**
 * Handles port toggle events from DevicePortsTable
 * DEPRECATED: Legacy function for old port management system
 */
// function handlePortToggle(event: { port: string, newState: string }) {
//   console.log(`[DeviceForm] Port toggle handled: ${event.port} -> ${event.newState}`)
// }

// Initialize templates on mount
onMounted(() => {
  loadDeviceTemplates()
})

// Watch for relay port changes - handle "–ü—Ä–∞–∑–µ–Ω" selection
watch(() => formData.value.relayPort, (newRelayPort, oldRelayPort) => {
  // If relay port becomes null and we're in relay mode, switch to direct
  if (newRelayPort === null && formData.value.connectionMethod === 'relay' && oldRelayPort !== null) {
    formData.value.connectionMethod = 'direct'
    formData.value.relayId = ''
    selectedRelay.value = null
    console.log('[DeviceForm] Relay port set to null - switched to direct connection')
  }
})

// Watch for connection method changes - clear relay data when switching to direct
watch(() => formData.value.connectionMethod, (newMethod, oldMethod) => {
  if (newMethod === 'direct' && oldMethod === 'relay') {
    formData.value.relayId = ''
    formData.value.relayPort = null
    selectedRelay.value = null
    console.log('[DeviceForm] Switched to direct connection - cleared relay data')
  }
})

// Watch for device changes
watch(() => props.device, async (newDevice) => {
  if (newDevice) {
    console.log('[DeviceForm] Loading device for edit:', newDevice)
    const controllerId = newDevice.controllerId?._id || newDevice.controllerId || ''
    
    formData.value = {
      name: newDevice.name || '',
      type: newDevice.type || '',
      physicalType: newDevice.physicalType || '',
      category: newDevice.category || '',
      controllerId: controllerId,
      connectionMethod: newDevice.connectionMethod || 'direct',
      relayId: newDevice.relayId || '',
      relayPort: newDevice.relayPort || null,
      ports: newDevice.ports || (newDevice.port ? [newDevice.port] : []), // Support legacy single port
      description: newDevice.description || '',
      isActive: newDevice.isActive !== undefined ? newDevice.isActive : true,
      priority: newDevice.priority || 'normal',
      healthCheckEnabled: newDevice.healthCheckEnabled ?? false,
      icon: newDevice.icon || 'device_hub',
      unit: newDevice.unit || null,
      validationConfig: newDevice.validationConfig ? {
        enabled: newDevice.validationConfig.enabled ?? false,
        expectedMin: newDevice.validationConfig.expectedMin ?? 0,
        expectedMax: newDevice.validationConfig.expectedMax ?? 100,
        physicalMin: newDevice.validationConfig.physicalMin ?? 0,
        physicalMax: newDevice.validationConfig.physicalMax ?? 1023,
        maxChangeRate: newDevice.validationConfig.maxChangeRate ?? 10,
        historyWindow: newDevice.validationConfig.historyWindow ?? 24,
        stuckValueThreshold: newDevice.validationConfig.stuckValueThreshold ?? 30
      } : {
        enabled: false,
        expectedMin: 0,
        expectedMax: 100,
        physicalMin: 0,
        physicalMax: 1023,
        maxChangeRate: 10,
        historyWindow: 24,
        stuckValueThreshold: 30
      }
    }
    
    console.log('[DeviceForm] Populated formData:', formData.value)
    
    // Set selected template if device has a type
    if (newDevice.type) {
      console.log(`[DeviceForm] Looking for template with type: ${newDevice.type}`)
      console.log(`[DeviceForm] Available templates:`, deviceTemplates.value.map(t => t.type))
      const template = deviceTemplates.value.find(t => t.type === newDevice.type)
      console.log(`[DeviceForm] Found template:`, template ? template.displayName : 'NOT FOUND')
      selectedTemplate.value = template
      
      // If template not found and we have a device type, reload templates
      if (!template && deviceTemplates.value.length === 0) {
        console.log('[DeviceForm] Templates not loaded, reloading...')
        await loadDeviceTemplates()
        const retryTemplate = deviceTemplates.value.find(t => t.type === newDevice.type)
        selectedTemplate.value = retryTemplate
        console.log(`[DeviceForm] Retry found template:`, retryTemplate ? retryTemplate.displayName : 'STILL NOT FOUND')
      }
    }
    
    // Load relays if device has a controller and uses relay connection
    if (controllerId) {
      await loadRelaysForController(controllerId)
      
      // Set selected relay if device uses relay connection
      if (newDevice.connectionMethod === 'relay' && newDevice.relayId) {
        const relay = relays.value.find(r => r._id === newDevice.relayId)
        if (relay) {
          selectedRelay.value = relay
          console.log(`[DeviceForm] Selected relay for edit:`, relay.name, `Port: ${newDevice.relayPort}`)
        } else {
          console.warn(`[DeviceForm] Could not find relay with ID: ${newDevice.relayId}`)
        }
      }
    }
  } else {
    // Reset form for new device
    formData.value = {
      name: '',
      type: '',
      physicalType: '',
      category: '',
      controllerId: '',
      connectionMethod: 'direct',
      relayId: '',
      relayPort: null,
      ports: [],
      description: '',
      isActive: true,
      priority: 'normal',
      healthCheckEnabled: false,
      icon: 'device_hub',
      unit: null,
      validationConfig: {
        enabled: false,
        expectedMin: 0,
        expectedMax: 100,
        physicalMin: 0,
        physicalMax: 1023,
        maxChangeRate: 10,
        historyWindow: 24,
        stuckValueThreshold: 30
      }
    }
    selectedTemplate.value = null
  }
}, { immediate: true })

// DEBUG: Watch for healthCheckEnabled changes to track when toggle is used
watch(() => formData.value.healthCheckEnabled, (newEnabled, oldEnabled) => {
  console.log(`[DeviceForm] üîç Health check toggle changed: ${oldEnabled} -> ${newEnabled}`)
  console.log('[DeviceForm] üîç Current healthCheckEnabled:', formData.value.healthCheckEnabled)
})

// DevicePortsTable handles all port-related logic now



</script>

<style scoped>
.port-details {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-top: 4px;
}

.parameter-table {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
}

.test-section {
  padding: 12px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  background: #f9f9f9;
}

.test-device-btn {
  font-weight: 500;
}

.test-result {
  animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

.disabled-controller {
  opacity: 0.5;
}
</style>

<style scoped>
.parameter-table {
  border: 1px solid #e0e0e0;
  border-radius: 4px;
}

.parameter-table :deep(.q-table__container) {
  border-radius: 4px;
}
</style>