/*
 * Arduino Uno R4 WiFi - WiFi Communication Base Template (v5 Clean)
 * Delimited text format - no JSON parsing for commands
 * Generated by Hydroponics v5 Firmware Generator
 */

// === WIFI LIBRARY ===
#include <WiFiS3.h>
#include <WiFiUdp.h>

// GENERATOR_INCLUDES_PLACEHOLDER

// === CONFIGURATION ===
#define SERIAL_BAUD 9600
#define UDP_PORT 8888
#define FIRMWARE_VERSION "1.0-v5"
#define DEVICE_TYPE "arduino_uno_r4_wifi"

// WiFi credentials (hardcoded for v5.0)
const char* WIFI_SSID = "Penka";
const char* WIFI_PASSWORD = "7806130560";

// === CAPABILITIES ===
// GENERATOR_CAPABILITIES_ARRAY_PLACEHOLDER

// === GLOBALS ===
WiFiUDP udp;
unsigned long startTime = 0;
char commandBuffer[64];
int commandPos = 0;

// GENERATOR_GLOBALS_PLACEHOLDER

// === RESET FUNCTION ===
void(* resetFunc) (void) = 0;

// === UTILITY FUNCTIONS ===
String getMacAddress() {
  byte mac[6];
  WiFi.macAddress(mac);
  String macStr = "";
  for (int i = 5; i >= 0; i--) {
    if (mac[i] < 16) macStr += "0";
    macStr += String(mac[i], HEX);
    if (i > 0) macStr += ":";
  }
  macStr.toUpperCase();
  return macStr;
}

// GENERATOR_FUNCTIONS_PLACEHOLDER

// === SETUP ===
void setup() {
  Serial.begin(SERIAL_BAUD);
  while (!Serial && millis() < 3000); // Wait up to 3s for serial
  
  startTime = millis();
  
  Serial.println(F("\n=== Arduino Uno R4 WiFi Starting ==="));
  Serial.print(F("Firmware: "));
  Serial.println(FIRMWARE_VERSION);
  
  // Check WiFi module
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println(F("WiFi module not detected!"));
    while (true); // Stop execution
  }
  
  // Connect to WiFi
  Serial.print(F("Connecting to WiFi: "));
  Serial.println(WIFI_SSID);
  
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  unsigned long startAttempt = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - startAttempt < 20000) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print(F("WiFi connected! IP: "));
    Serial.println(WiFi.localIP());
    Serial.print(F("MAC: "));
    Serial.println(getMacAddress());
    
    // Start UDP listener
    udp.begin(UDP_PORT);
    Serial.print(F("UDP server started on port "));
    Serial.println(UDP_PORT);
  } else {
    Serial.println(F("WiFi connection failed - halting"));
    while (true); // Stop execution
  }
  
  Serial.println(F("=== Setup Complete ===\n"));
}

// === MAIN LOOP ===
void loop() {
  // Check for UDP packets
  int packetSize = udp.parsePacket();
  
  if (packetSize > 0) {
    char incomingPacket[256];
    int len = udp.read(incomingPacket, 255);
    if (len > 0) {
      incomingPacket[len] = 0;
    }
    
    // Check if it's a discovery request
    if (strcmp(incomingPacket, "HYDROPONICS_DISCOVERY") == 0) {
      handleDiscovery();
    } else {
      // Regular command - process and respond
      String response = processCommand(String(incomingPacket));
      
      // Send response back via UDP
      udp.beginPacket(udp.remoteIP(), udp.remotePort());
      udp.print(response);
      udp.endPacket();
      
      // Debug log
      Serial.print(F("[UDP] Command: "));
      Serial.print(incomingPacket);
      Serial.print(F(" -> "));
      Serial.println(response);
    }
  }
  
  delay(1); // Small delay for stability
  handleSerial();
}

// === SERIAL HANDLER (For Debugging) ===
void handleSerial() {
  while (Serial.available() > 0) {
    char c = Serial.read();
    
    if (c == '\n') {
      commandBuffer[commandPos] = '\0'; // Terminate string
      
      if (commandPos > 0) {
        String response = processCommand(String(commandBuffer));
        Serial.println(response);
      }
      
      commandPos = 0; // Reset buffer
    } 
    else if (c != '\r' && commandPos < sizeof(commandBuffer) - 1) {
      commandBuffer[commandPos++] = c;
    }
  }
}

// === DISCOVERY HANDLER ===
void handleDiscovery() {
  // Build discovery response JSON
  String response = "{";
  response += "\"type\":\"ANNOUNCE\",";
  response += "\"mac\":\"" + getMacAddress() + "\",";
  response += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  response += "\"model\":\"" + String(DEVICE_TYPE) + "\",";
  response += "\"firmware\":\"" + String(FIRMWARE_VERSION) + "\",";
  response += "\"capabilities\":[";
  
  for (int i = 0; i < CAPABILITIES_COUNT; i++) {
    response += "\"";
    response += CAPABILITIES[i];
    response += "\"";
    if (i < CAPABILITIES_COUNT - 1) response += ",";
  }
  
  response += "]}";
  
  // Send discovery response
  udp.beginPacket(udp.remoteIP(), udp.remotePort());
  udp.print(response);
  udp.endPacket();
  
  Serial.println(F("[Discovery] Response sent"));
}

// === COMMAND PARSER (v5 Delimited Text Only) ===
String processCommand(String input) {
  char cmdBuffer[64];
  strncpy(cmdBuffer, input.c_str(), sizeof(cmdBuffer) - 1);
  cmdBuffer[sizeof(cmdBuffer) - 1] = '\0';
  
  // Find delimiter position and isolate command name
  char* delimiter = strchr(cmdBuffer, '|');
  if (delimiter) {
    *delimiter = '\0';  // Terminate string at delimiter to isolate command
  }
  const char* cmd = cmdBuffer;
  
  // === SYSTEM COMMANDS ===
  
  if (strcmp(cmd, "PING") == 0) {
    return "{\"ok\":1,\"pong\":1}";
  }
  
  else if (strcmp(cmd, "INFO") == 0) {
    String response = "{\"ok\":1,\"up\":";
    response += millis();
    response += ",\"ver\":\"";
    response += FIRMWARE_VERSION;
    response += "\",\"capabilities\":[";
    for (int i = 0; i < CAPABILITIES_COUNT; i++) {
      response += "\"";
      response += CAPABILITIES[i];
      response += "\"";
      if (i < CAPABILITIES_COUNT - 1) response += ",";
    }
    response += "]}";
    return response;
  }
  
  else if (strcmp(cmd, "STATUS") == 0) {
    String response = "{\"ok\":1,\"status\":\"running\",\"up\":";
    response += millis();
    response += "}";
    return response;
  }
  
  else if (strcmp(cmd, "RESET") == 0) {
    Serial.println(F("Resetting device..."));
    delay(100);
    resetFunc();
    return "{\"ok\":1,\"msg\":\"Resetting\"}";
  }
  
  // GENERATOR_DISPATCHER_PLACEHOLDER
  
  else {
    return "{\"ok\":0,\"error\":\"ERR_INVALID_COMMAND\"}";
  }
}
