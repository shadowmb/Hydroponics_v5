/*
 * Arduino Uno R4 - Serial Communication Base Template (v5 Clean)
 * Delimited text format - no JSON parsing for commands
 * Generated by Hydroponics v5 Firmware Generator
 */

// GENERATOR_INCLUDES_PLACEHOLDER

// === CONFIGURATION ===
#define SERIAL_BAUD 9600
#define FIRMWARE_VERSION "1.0-v5"
#define DEVICE_TYPE "arduino_uno_r4_serial"

// === CAPABILITIES ===
// GENERATOR_CAPABILITIES_ARRAY_PLACEHOLDER

// === GLOBALS ===
unsigned long startTime = 0;
char commandBuffer[64];
int commandPos = 0;

// GENERATOR_GLOBALS_PLACEHOLDER

// === RESET FUNCTION ===
void(* resetFunc) (void) = 0;

// === UTILITY FUNCTIONS ===
// Note: freeMemory() removed as it is AVR specific and not available on Renesas RA4M1

// GENERATOR_FUNCTIONS_PLACEHOLDER

// === SETUP ===
void setup() {
  Serial.begin(SERIAL_BAUD);
  while (!Serial && millis() < 3000); // Wait up to 3s for serial
  
  startTime = millis();
  
  Serial.println(F("\n=== Arduino Uno R4 Serial Starting ==="));
  Serial.print(F("Firmware: "));
  Serial.println(FIRMWARE_VERSION);
  Serial.println(F("=== Setup Complete ===\n"));
}

// === MAIN LOOP ===
void loop() {
  handleSerial();
  delay(1); // Small delay for stability
}

// === SERIAL HANDLER ===
void handleSerial() {
  while (Serial.available() > 0) {
    char c = Serial.read();
    
    if (c == '\n') {
      commandBuffer[commandPos] = '\0'; // Terminate string
      
      if (commandPos > 0) {
        String response = processCommand(String(commandBuffer));
        Serial.println(response);
      }
      
      commandPos = 0; // Reset buffer
    } 
    else if (c != '\r' && commandPos < sizeof(commandBuffer) - 1) {
      commandBuffer[commandPos++] = c;
    }
  }
}

// === COMMAND PARSER (v5 Delimited Text Only) ===
String processCommand(String input) {
  char cmdBuffer[64];
  strncpy(cmdBuffer, input.c_str(), sizeof(cmdBuffer) - 1);
  cmdBuffer[sizeof(cmdBuffer) - 1] = '\0';
  
  // Find delimiter position and isolate command name
  char* delimiter = strchr(cmdBuffer, '|');
  if (delimiter) {
    *delimiter = '\0';  // Terminate string at delimiter to isolate command
  }
  const char* cmd = cmdBuffer;
  
  // === SYSTEM COMMANDS ===
  
  if (strcmp(cmd, "PING") == 0) {
    return "{\"ok\":1,\"pong\":1}";
  }
  
  else if (strcmp(cmd, "INFO") == 0) {
    String response = "{\"ok\":1,\"up\":";
    response += millis();
    response += ",\"ver\":\"";
    response += FIRMWARE_VERSION;
    response += "\",\"capabilities\":[";
    for (int i = 0; i < CAPABILITIES_COUNT; i++) {
      response += "\"";
      response += CAPABILITIES[i];
      response += "\"";
      if (i < CAPABILITIES_COUNT - 1) response += ",";
    }
    response += "]}";
    return response;
  }
  
  else if (strcmp(cmd, "STATUS") == 0) {
    String response = "{\"ok\":1,\"status\":\"running\",\"up\":";
    response += millis();
    response += "}";
    return response;
  }
  
  else if (strcmp(cmd, "RESET") == 0) {
    Serial.println(F("Resetting device..."));
    delay(100);
    resetFunc();
    return "{\"ok\":1,\"msg\":\"Resetting\"}";
  }
  
  // GENERATOR_DISPATCHER_PLACEHOLDER
  
  else {
    return "{\"ok\":0,\"error\":\"ERR_INVALID_COMMAND\"}";
  }
}
